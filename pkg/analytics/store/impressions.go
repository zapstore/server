package store

import (
	"context"
	"fmt"
	"slices"
	"strings"
	"time"

	"github.com/nbd-wtf/go-nostr"
	eventPkg "github.com/zapstore/server/pkg/events"
)

// Source represents where the impression was made.
type Source string

const (
	SourceApp     Source = "app"
	SourceWeb     Source = "web"
	SourceUnknown Source = "unknown"
)

// Type represents the type of impression, which is determined by the REQ.
// For example, a "detail" impression is made when the client requests kind = 32267 (app), 'd' = <app_id>.
type Type string

const (
	TypeFeed         Type = "feed"
	TypeDetail       Type = "detail"
	TypeSearch       Type = "search"
	TypeStack        Type = "stack"
	TypeUndetermined Type = "undetermined"
)

// Impression of an app.
type Impression struct {
	AppID       string
	AppPubkey   string
	Day         string // formatted as "YYYY-MM-DD"
	Source      Source
	Type        Type
	CountryCode string // ISO 2 letter code
}

// ImpressionCount is an Impression paired with its occurrence count.
type ImpressionCount struct {
	Impression
	Count int
}

// ImpressionSource returns the Source derived from the REQ subscription id.
func ImpressionSource(id string) Source {
	switch {
	case strings.HasPrefix(id, "app-"):
		return SourceApp
	case strings.HasPrefix(id, "web-"):
		return SourceWeb
	default:
		return SourceUnknown
	}
}

// ImpressionType returns the Type derived from a single filter.
func ImpressionType(filter nostr.Filter) Type {
	hasApp := slices.Contains(filter.Kinds, eventPkg.KindApp)
	hasStack := slices.Contains(filter.Kinds, eventPkg.KindAppSet)

	if hasStack && !hasApp {
		return TypeStack
	}

	if hasApp {
		dTags := len(filter.Tags["d"])
		switch {
		case dTags == 0 && filter.Search == "":
			return TypeFeed
		case dTags == 0 && filter.Search != "":
			return TypeSearch
		case dTags > 0:
			return TypeDetail
		}
	}
	return TypeUndetermined
}

// NewImpressions creates the impressions generated by a single entity's REQ (id, filters),
// matched against the nostr events served in response to it.
// The impressions will have to be deduplicated into ImpressionCount before being passed to the store.
func NewImpressions(country string, id string, filters nostr.Filters, events []nostr.Event) []Impression {
	day := Today()
	source := ImpressionSource(id)
	impressions := make([]Impression, 0, len(events))

	for _, f := range filters {
		typ := ImpressionType(f)
		if typ == TypeUndetermined {
			continue
		}

		for _, event := range matchingEvents(f, events) {
			switch {
			case typ == TypeStack && event.Kind == eventPkg.KindAppSet:
				// One impression per app inside the app set
				pubkeys, appIDs := eventPkg.ResolveAppSet(&event)
				for i := range len(appIDs) {
					impressions = append(impressions, Impression{
						AppID:       appIDs[i],
						AppPubkey:   pubkeys[i],
						Day:         day,
						Source:      source,
						Type:        typ,
						CountryCode: country,
					})
				}

			default:
				// One impression for the app
				appID := event.Tags.GetD()
				if appID == "" {
					continue
				}
				impressions = append(impressions, Impression{
					AppID:       appID,
					AppPubkey:   event.PubKey,
					Day:         day,
					Source:      source,
					Type:        typ,
					CountryCode: country,
				})
			}
		}
	}
	return impressions
}

// Today returns the current day formatted as "YYYY-MM-DD".
func Today() string {
	return time.Now().UTC().Format("2006-01-02")
}

// matchingEvents returns the subset of events that match the given filter.
func matchingEvents(f nostr.Filter, events []nostr.Event) []nostr.Event {
	var matched []nostr.Event
	for _, e := range events {
		if f.Matches(&e) {
			matched = append(matched, e)
		}
	}
	return matched
}

// SaveImpressions writes the given batch of counted impressions to the database.
// On conflict it increments the existing count. An empty batch is a no-op.
func (s *Store) SaveImpressions(ctx context.Context, batch []ImpressionCount) error {
	if len(batch) == 0 {
		return nil
	}

	tx, err := s.db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	stmt, err := tx.PrepareContext(ctx, `
		INSERT INTO impressions (app_id, app_pubkey, day, source, type, country_code, count)
		VALUES (?, ?, ?, ?, ?, ?, ?)
		ON CONFLICT(app_id, app_pubkey, day, source, type, country_code)
		DO UPDATE SET count = impressions.count + excluded.count
	`)
	if err != nil {
		return fmt.Errorf("failed to prepare statement: %w", err)
	}
	defer stmt.Close()

	for _, impression := range batch {
		if _, err := stmt.ExecContext(
			ctx,
			impression.AppID,
			impression.AppPubkey,
			impression.Day,
			string(impression.Source),
			string(impression.Type),
			impression.CountryCode,
			impression.Count,
		); err != nil {
			return fmt.Errorf("failed to execute statement: %w", err)
		}
	}

	if err := tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}
	return nil
}
